---
title: Joined Search
---

## Overview

Joined search refers to a single search query that can search across multiple tables. For instance, you have two tables: `mock_products`
and `mock_reviews`, and want to find reviews about certain products that match specific keywords.

To achieve joined search, we introduce the concept of a **materialized column**. A materialized column is a column that can be added to any table, stores precomputed data from related tables, and refreshes in real time. This approach enables efficient search across normalized data without the need to perform expensive joins at query time.

## Basic Usage

In this example, we will create two tables: `mock_products` and `mock_reviews`.

```sql
CREATE TABLE mock_products (
    id SERIAL PRIMARY KEY,
    product_name TEXT,
    category TEXT
);

INSERT INTO mock_products (product_name, category)
VALUES ('Flat Screen TV', 'Electronics'), ('MP3 Player', 'Electronics');

SELECT * FROM mock_products;
```

<Accordion title="Expected Response">
```csv
 id |  product_name  |  category
----+----------------+-------------
  1 | Flat Screen TV | Electronics
  2 | MP3 Player     | Electronics
(2 rows)
```
</Accordion>

Reviews are tied to products by the `product_id` foreign key.

```sql
CREATE TABLE mock_reviews (
    review_id SERIAL PRIMARY KEY,
    product_id INT REFERENCES mock_products(id),
    review TEXT
);

INSERT INTO mock_reviews (product_id, review)
VALUES (1, 'Amazing resolution'), (2, 'Amazing sound'), (2, 'Would recommend');

SELECT * FROM mock_reviews;
```

<Accordion title="Expected Response">
```csv
 review_id | product_id |       review
-----------+------------+--------------------
         1 |          1 | Amazing resolution
         2 |          2 | Amazing sound
         3 |          2 | Would recommend
(3 rows)
```
</Accordion>

Let's add a materialized column called `product_name` to `mock_reviews`, which associates every review
with a product name.

```sql
ALTER TABLE mock_reviews ADD COLUMN product_name TEXT;

UPDATE mock_reviews
SET product_name = mock_products.product_name
FROM mock_products
WHERE mock_reviews.product_id = mock_products.id;
```

Postgres triggers can be used to keep `product_name` up to date whenever a new row is inserted into `mock_reviews`.

```sql
CREATE OR REPLACE FUNCTION update_product_name()
RETURNS TRIGGER AS $$
BEGIN
    SELECT product_name INTO NEW.product_name
    FROM mock_products
    WHERE id = NEW.product_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_product_name_trigger
BEFORE INSERT OR UPDATE ON mock_reviews
FOR EACH ROW EXECUTE FUNCTION update_product_name();
```

Now, we can index and search `mock_reviews`:

```sql
CALL paradedb.create_bm25(
  index_name => 'reviews',
  table_name => 'mock_reviews',
  key_field => 'review_id',
  text_fields => paradedb.field('review') || paradedb.field('product_name')
);

SELECT review, product_name
FROM reviews.search('review:amazing OR product_name:tv', limit_rows => 2);
```

<Accordion title="Expected Response">
```csv
       review       |  product_name
--------------------+----------------
 Amazing resolution | Flat Screen TV
 Amazing sound      | MP3 Player
(2 rows)
```
</Accordion>

Whenever a new row is added to `mock_reviews`, the associated `product_name` is automatically computed.

```sql
INSERT INTO mock_reviews (product_id, review)
VALUES (2, 'Excellent quality');

SELECT review, product_name
FROM reviews.search('review:quality', limit_rows => 1);
```

<Accordion title="Expected Response">
```csv
      review       | product_name
-------------------+--------------
 Excellent quality | MP3 Player
(1 row)
```
</Accordion>

## Multiple Joined Columns

If a search query needs to reference multiple columns from another table, these columns can be combined
into a single `JSONB` materialized column. For instance, let's say we wish to join every review with
`product_name` and `category`, which are columns in `mock_products`.

```sql
ALTER TABLE mock_reviews ADD COLUMN product_details JSONB;

UPDATE mock_reviews
SET product_details = jsonb_build_object(
    'product_name', mock_products.product_name,
    'category', mock_products.category
)
FROM mock_products
WHERE mock_reviews.product_id = mock_products.id;

SELECT review, product_details from mock_reviews;
```

<Accordion title="Expected Response">
```csv
       review       |                        product_details
--------------------+---------------------------------------------------------------
 Amazing resolution | {"category": "Electronics", "product_name": "Flat Screen TV"}
 Amazing sound      | {"category": "Electronics", "product_name": "MP3 Player"}
 Would recommend    | {"category": "Electronics", "product_name": "MP3 Player"}
 Excellent quality  | {"category": "Electronics", "product_name": "MP3 Player"}
(4 rows)
```
</Accordion>

We can search over the `product_details` column using ParadeDB's JSON full text search.

```sql
CALL paradedb.create_bm25(
  index_name => 'detailed_reviews',
  table_name => 'mock_reviews',
  key_field => 'review_id',
  text_fields => paradedb.field('review'),
  json_fields => paradedb.field('product_details')
);

SELECT review, product_details
FROM detailed_reviews.search(
  'product_details.product_name:tv AND review:amazing',
  limit_rows => 1
);
```

<Accordion title="Expected Response">
```csv
       review       |                        product_details
--------------------+---------------------------------------------------------------
 Amazing resolution | {"category": "Electronics", "product_name": "Flat Screen TV"}
(1 row)
```
</Accordion>

Finally, let's create a trigger that updates `product_details` whenever a review is inserted or updated.

```sql
CREATE OR REPLACE FUNCTION update_product_details()
RETURNS TRIGGER AS $$
BEGIN
    SELECT jsonb_build_object(
        'product_name', product_name,
        'category', category
    ) INTO NEW.product_details
    FROM mock_products
    WHERE mock_products.id = NEW.product_id;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_product_details_trigger
BEFORE INSERT OR UPDATE ON mock_reviews
FOR EACH ROW
EXECUTE FUNCTION update_product_details();
```

Let's insert a new review into `mock_reviews` and verify that the trigger is working.

```sql
INSERT INTO mock_reviews (product_id, review) VALUES (2, 'would buy again');

SELECT review, product_details
FROM detailed_reviews.search('product_details.product_name:player AND review:buy');
```

<Accordion title="Expected Response">
```csv
     review      |                      product_details
-----------------+-----------------------------------------------------------
 would buy again | {"category": "Electronics", "product_name": "MP3 Player"}
(1 row)
```
</Accordion>

## For Further Assistance

Improving search over joined data is an active area of development for ParadeDB. If the above strategies do not satisfy
your use case, please [open a Github issue](https://github.com/paradedb/paradedb/issues) or [contact support](mailto:support@paradedb.com) and
we'll be happy to discuss alternative solutions.
