---
title: "pg_bm25: Elastic-Quality, Full Text Search Inside Postgres"
og:image: "/blog/images/bm25.png"
---

<img src="/blog/images/bm25.png" noZoom />

We're unveiling `pg_bm25`: a Rust-based Postgres extension that enables full text search using the BM25 algorithm 
inside Postgres.

Today, Postgres' native full text search, which uses the `tsvector` type, has two main problems:

1. **Performance**: Searching and ranking over large tables is sluggish. When tables grow to millions of rows, a single full text search can take several minutes to complete.
2. **Functionality**: Postgres has limited support for functionalities like fuzzy search, relevance tuning, or 
BM25 relevance scoring, which are the bread and butter of modern search engines.

`pg_bm25` aims to bridge the gap between the native capabilities of Postgres’ full text search and those of a specialized search engine like ElasticSearch. 
The long-term goal is to eliminate the need to bring a cumbersome service like ElasticSearch into the data stack.

Some features of `pg_bm25` include:

- 100% Postgres native, with zero dependencies on an external search engine 
- Built on top of Tantivy, a Rust-based alternative to the Apache Lucene search library
- Query times over 1M rows are 20x faster compared to `tsquery` and `ts_rank`, Postgres' built-in full text search and sort functions
- Support for autocomplete, fuzzy search, highlighting, relevance tuning, and boolean queries
- BM25 relevance scoring
- Real-time search — new data is immediately searchable without manual reindexing
- No complex query language — just search over your tables with SQL

## What is BM25?

BM25, which stands for Best Matching 25, is the go-to choice for most modern search engines. 
It ranks documents by considering how often a term appears and how unique that term is across all documents. 
This type of search is especially useful for matching by exact keywords, abbreviations, and proper nouns. 
When used in conjunction with a vector search extension like `pgvector`, `pg_bm25` is the missing puzzle piece that 
unlocks powerful hybrid search functionalities within Postgres itself (subject of a future blog post).

## Using pg_bm25

To run `pg_bm25` or install it inside an existing, self-managed Postgres database, please see the extension’s 
[README](https://github.com/paradedb/paradedb/tree/dev/pg_bm25).

Out of the box, `pg_bm25` provides a table called `paradedb.mock_items` you can use for testing. 
To begin, let’s index this table:

```sql 
CREATE TABLE mock_items AS SELECT * FROM paradedb.mock_items;
CREATE INDEX idx_mock_items ON mock_items USING bm25 ((mock_items.*));
```

Now that the table is indexed, you can run full text queries against it:

```sql
SELECT description, rating, category
FROM mock_items
WHERE mock_items @@@ 'description:keyboard OR category:electronics'
LIMIT 5;
```

<Accordion title="Expected Response">
```csv
         description         | rating |  category
-----------------------------+--------+-------------
 Plastic Keyboard            |      4 | Electronics
 Ergonomic metal keyboard    |      4 | Electronics
 Innovative wireless earbuds |      5 | Electronics
 Fast charging power bank    |      4 | Electronics
 Bluetooth-enabled speaker   |      3 | Electronics
(5 rows)
```
</Accordion>

In NoSQL search engines, metadata filtering requires a complex query language. Fortunately, SQL 
provides an ergonomic interface for filtering:

```sql
SELECT description, rating, category
FROM mock_items
WHERE mock_items @@@ 'description:keyboard OR category:electronics'
AND rating > 4;
```

As queries become more complex, the readability of SQL begins to shine. For reference, here's what 
an equivalent query would look like if this table were stored in ElasticSearch:

```json
{
  "query": {
    "bool": {
      "must": [
        {
          "bool": {
            "should": [
              { "match": { "description": "keyboard" } },
              { "match": { "category": "electronics" } }
            ]
          }
        }
      ],
      "filter": [
        { "range": { "rating": { "gt": 4 } } }
      ]
    }
  },
  "_source": ["description", "rating", "category"]
}
```

## Scoring and Highlighting 

BM25 scoring, which ranks the relevance of each row, and highlighting, which returns the exact snippets of 
text that match a given keyword, are provided as Postgres functions:

```sql
SELECT description, rating, category, paradedb.rank_bm25(ctid), paradedb.highlight_bm25(ctid, 'description')
FROM mock_items
WHERE mock_items @@@ 'description:keyboard OR category:electronics'
LIMIT 5;
```

<Accordion title="Expected Response">
```csv
 id |         description         | rating |  category   | rank_bm25 |         highlight_bm25
----+-----------------------------+--------+-------------+-----------+---------------------------------
  1 | Ergonomic metal keyboard    |      4 | Electronics | 4.9403534 | Ergonomic metal <b>keyboard</b>
  2 | Very plasticy keyboard      |      4 | Electronics | 4.9403534 | Very plasticy <b>keyboard</b>
 12 | Innovative wireless earbuds |      5 | Electronics | 2.1096356 |
 22 | Fast charging power bank    |      4 | Electronics | 2.1096356 |
 32 | Bluetooth-enabled speaker   |      3 | Electronics | 2.1096356 |
(5 rows)
```
</Accordion>

## Typo-Tolerant Fuzzy Search 

One feature we're especially proud of is `pg_bm25`'s support for typo-tolerant `SELECT` queries via fuzzy search.
For instance, consider a query with the text string `keybroadd`. Whereas a normal SQL query would return nothing,
`pg_bm25` finds results with the word `keyboard`.

```sql 
SELECT description, rating, category
FROM mock_items
WHERE mock_items @@@ 'keybroadd:::fuzzy_fields=description';
```

<Accordion title="Expected Response">
```csv
       description        | rating |  category
--------------------------+--------+-------------
 Ergonomic metal keyboard |      4 | Electronics
 Plastic Keyboard         |      4 | Electronics
(2 rows)
```
</Accordion>

## Autocomplete

`pg_bm25` supports basic regex syntax, which enables autocomplete. Autocomplete is useful for search boxes that 
show suggestions to users as they type:

```sql 
SELECT description, rating, category
FROM mock_items
WHERE mock_items @@@ 'key:::prefix_fields=description';
```

<Accordion title="Expected Response">
```csv
       description        | rating |  category
--------------------------+--------+-------------
 Ergonomic metal keyboard |      4 | Electronics
 Plastic Keyboard         |      4 | Electronics
(2 rows)
```
</Accordion>

## Real-Time Search

New data that arrives or rows that are changed are automatically reindexed and searchable. For instance,
let's create and search for a new row in our table: 

```sql
INSERT INTO mock_items (description, rating, category) 
VALUES ('New keyboard', 5, 'Electronics');

SELECT description, rating, category
FROM mock_items
WHERE mock_items @@@ 'description:keyboard OR category:electronics'
LIMIT 5;
```

<Accordion title="Expected Response">
```csv
         description         | rating |  category
-----------------------------+--------+-------------
 New keyboard                |      5 | Electronics
 Plastic Keyboard            |      4 | Electronics
 Ergonomic metal keyboard    |      4 | Electronics
 Innovative wireless earbuds |      5 | Electronics
 Fast charging power bank    |      4 | Electronics
(5 rows)
```
</Accordion>

## Benchmarks 

On a table with one million rows, `pg_bm25` indexes 50 seconds faster than `tsvector` and ranks results 
20x faster. Indexing and search times are nearly identical to those of a dedicated ElasticSearch instance.
With further optimizations, we're aiming to reduce the query times compared to ElasticSearch 
by an additional 2x. 

More detailed benchmark results can be found in the extension 
[README](https://github.com/paradedb/paradedb/tree/dev/pg_bm25#benchmarks).

## Wrapping Up 

`pg_bm25`'s API is built transparently on top of Tantivy. The immediate goal of the core team is to enable all of
Tantivy's query types and custom tokenizers within `pg_bm25` by exposing more of Tantivy's API through Postgres. 
This will unlock missing features like faceted search, while providing users of `pg_bm25` with a familiar 
interface — `pg_bm25` aims to use the same query names and parameters used by Tantivy.

As an open source project, we invite community members to contribute to our 
[Github issues](https://github.com/paradedb/paradedb/issues). You can show your support by 
[giving us a star](https://github.com/paradedb/paradedb) or [trying out `pg_bm25`](https://github.com/paradedb/paradedb/tree/dev/pg_bm25#usage) 
for yourself.
