---
title: Autocomplete
---

In user-facing search, autocomplete refers to the process of suggesting relevant results as the user is typing.
Several of ParadeDB's search APIs can be used to build and tune a full-fledged autocomplete experience.

<Note>
This guide uses the [`mock_items` table](/api-reference/introduction).
</Note>

## Fuzzy Term

Suppose we want to find all documents containing `shoes`, but the user typed in `shoez`. The `fuzzy_term` query can find search results that approximately match the query term while allowing for minor typos in the input.

```sql
SELECT description, rating, category
FROM search_idx.search(
    query => paradedb.fuzzy_term(
        field => 'description',
        value => 'shoez'
    )
);
```

<Accordion title="Expected Response">
```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```
</Accordion>

## Fuzzy Phrase

Suppose the user provides a misspelled phrase like `ruining shoez` when searching for `running shoes`. Because `fuzzy_term` treats `value` as a single token,
passing the entire phrase to `fuzzy_term` will not yield any matches. Instead, the phrase should be pre-tokenized in the same way as
the `description` field and fed into a `boolean` query.

```sql
-- Pre-tokenize "ruining shoez"
WITH tokenized AS (
    SELECT token FROM paradedb.tokenize(
        paradedb.tokenizer('default'),
        'ruining shoez'
    )
)
-- Match a document if any of the tokens match
SELECT description, rating, category
FROM search_idx.search(
    query => paradedb.boolean(
        should => ARRAY[(
            SELECT array_agg(paradedb.fuzzy_term(field => 'description', value => token))
            FROM tokenized
        )]
    )
);
```

<Accordion title="Expected Response">
```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```
</Accordion>

## Multiple Fuzzy Fields

Suppose we want to compare a query against both `description` and `category`. The `boolean` query can be used to query across multiple fields.

```sql
-- Pre-tokenize "ruining shoez"
WITH tokenized AS (
    SELECT token FROM paradedb.tokenize(
        paradedb.tokenizer('default'),
        'ruining shoez'
    )
)
-- Match a document if any of the tokens match
SELECT description, rating, category FROM search_idx.search(
    query => paradedb.boolean(
        should => ARRAY[
            (
                SELECT array_agg(paradedb.fuzzy_term(field => 'description', value => token))
                FROM tokenized
            ),
            (
                SELECT array_agg(paradedb.fuzzy_term(field => 'category', value => token))
                FROM tokenized
            )
        ]
    )
);
```

<Accordion title="Expected Response">
```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```
</Accordion>

## Ngram Term

Suppose we want to suggest results when the user has only typed part of a word, like `sho`. In this scenario,
the [ngrams tokenizer](/api-reference/indexing/create_index#ngrams) can be used to convert documents into ngram tokens.

For the purpose of this example, let's assume that we have an index called `ngrams_idx`:

```sql
CALL paradedb.create_bm25(
    index_name => 'ngrams_idx',
    schema_name => 'public',
    table_name => 'mock_items',
    key_field => 'id',
    text_fields => paradedb.field(
        'description',
        tokenizer => paradedb.tokenizer('ngram', min_gram => 3, max_gram => 3, prefix_only => false)
    )
);
```

With `description` tokenized into n-grams, we can search for partial words.

```sql
SELECT description, rating, category
FROM ngrams_idx.search('description:sho');
```

<Accordion title="Expected Response">
```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```
</Accordion>

## Ngram Term Set

When querying against an ngrams field, all ngrams of the query must match in order for the document to be considered a match.
This means that a query like `hsoes` would not match `shoes`, because the `hso` token does not match any of the tokens of `shoes`.

To match documents where **any** token of the query matches, the tokens can be fed into a `term_set` query.

```sql
-- Pre-tokenize "hsoes"
WITH tokenized AS (
    SELECT token FROM paradedb.tokenize(
        paradedb.tokenizer('ngram', min_gram => 3, max_gram => 3, prefix_only => false),
        'hsoes'
    )
)
-- Match a document if any of the tokens match
SELECT description, rating, category
FROM ngrams_idx.search(
    query => paradedb.term_set(
        terms => ARRAY[
            (
                SELECT array_agg(paradedb.term(field => 'description', value => token))
                FROM tokenized
            )
        ]
    )
);
```

<Accordion title="Expected Response">
```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```
</Accordion>
