---
title: Text Search and Plain SQL
---

<Note>
  See the [overview](/api-reference/direct-sql/overview#getting-started) for
  creating the necessary example data
</Note>

As mentioned in the overview, the `@@@` operator asks the database to "find all rows matching a full text query condition".

ParadeDB performs certain optimizations to "push down" certain combinations of the `@@@` operator in a query into the
underlying text index, improving search performance.

In other situations, ParadeDB relies on Postgres' query planner to produce the most optimized query plan possible for
the given query.

## Text Search Queries using `AND`

Using our example table from the overview, if we're interested in finding all rows that are about "running shoes" in
the `description` field, we can write this query a few different ways. All of these ways are functionally identical, so
the form you choose is up to you and perhaps your query generation tools.

The following examples all return this record:

```csv
id |        description        | rating | category | in_stock |                       metadata                       |     created_at      | last_updated_date | latest_available_time
----+---------------------------+--------+----------+----------+------------------------------------------------------+---------------------+-------------------+-----------------------
 3 | Sleek running shoes       |      5 | Footwear | t        | {"color": "Blue", "location": "China"}               | 2023-04-28 10:55:43 | 2023-04-29        | 10:55:43
(1 row)
```

### One Query Clause

This demonstrates using a single text-based query using ParadeDB's query language.

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ 'description:shoes AND description:run';
```

### Two Clauses, Combined using `AND`

Another form would be to split the text-based query into its constituent parts, ANDing them together in SQL:

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ 'description:shoes' AND id @@@ 'description:run';
```

This is functionally equivalent to the example above, however ParadeDB is optimizing the query as if it were a single
text-search clause.

### Advanced Boolean Query

Alternatively, we can use ParadeDB's advanced search functions to declaratively build the same query

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ paradedb.boolean(
            must => ARRAY [
                        paradedb.term('description', 'shoe'),
                        paradedb.term('description', 'run')
                    ]
              );
```

### Combine them all

We can even mix-n-match these forms together. Say we want to also look for the word "sleek" in the `description`.

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ paradedb.boolean(
            must => ARRAY [
                        paradedb.term('description', 'shoe'),
                        paradedb.term('description', 'run')
                    ]
              )
   AND id @@@ 'description:sleek';
```

Here, we've combined two different forms of the `@@@` in one SQL statement, and ParadeDB transparently pushes down the
combined ANDed set into a single text search query.

The [Inspecting Query Plans](/api-reference/direct-sql/explain) section talks in detail about query plans, but it's good
to look at the query plan for this query. One might expect it to be some kind of IndexScan with either a filter or
perhaps a BitmapHeap scan with two BitmapAnd nodes.

Due to ParadeDB's ability to optimize certain queries, the plan is simply a single IndexScan:

```sql
EXPLAIN SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ paradedb.boolean(
            must => ARRAY [
                        paradedb.term('description', 'shoe'),
                        paradedb.term('description', 'run')
                    ]
              )
   AND id @@@ 'description:sleek';
                                                                                                                                                                                                >
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------>
 Index Scan using bm25_search_bm25_index on bm25_search  (cost=10.00..14.02 rows=1 width=609)
   Index Cond: ((id @@@ '{..., "query": {"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, ...
```

You can see that ParadeDB combined the individual `paradedb.boolean()` and `description:sleek` clauses into a single
"Boolean" query.

## Text Search Queries with `OR`

Using the `OR` operator is the same as the `AND` operator, however it's not an operator that Postgres allows ParadeDB to
optimize by pushing down the full query clause.

Using a similar query to the last `AND` query above,

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ paradedb.boolean(
            must => ARRAY [
                        paradedb.term('description', 'shoe'),
                        paradedb.term('description', 'run')
                    ]
              )
   OR id @@@ 'description:book';    -- ðŸ‘€ changed to OR and 'description:book'
```

(note the two clauses are `OR`'d together here)

we find three rows:

```csv
 id |        description        | rating | category | in_stock |                       metadata                       |     created_at      | last_updated_date | latest_available_time
----+---------------------------+--------+----------+----------+------------------------------------------------------+---------------------+-------------------+-----------------------
  3 | Sleek running shoes       |      5 | Footwear | t        | {"color": "Blue", "location": "China"}               | 2023-04-28 10:55:43 | 2023-04-29        | 10:55:43
  7 | Hardcover book on history |      2 | Books    | t        | {"color": "Brown", "location": "United States"}      | 2023-04-18 14:59:27 | 2023-04-19        | 14:59:27
 37 | Historical fiction book   |      3 | Books    | t        | {"color": "Multicolor", "location": "United States"} | 2023-04-21 10:35:40 | 2023-04-22        | 10:35:40
(3 rows)
```

And the query plan is in fact a multi-node BitmapHeapScan with a BitmapOR node performing two separate BitmapIndexScans:

```sql
                                                                                  QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on bm25_search  (cost=40.02..344.05 rows=3 width=609)
   Recheck Cond: ((id @@@ '{..., "query": {"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, ...
   ->  BitmapOr  (cost=20.02..20.02 rows=3 width=0)
         ->  Bitmap Index Scan on bm25_search_bm25_index  (cost=0.00..10.01 rows=1 width=0)
               Index Cond: (id @@@ '{..., "query": {"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, ...
         ->  Bitmap Index Scan on bm25_search_bm25_index  (cost=0.00..10.01 rows=2 width=0)
               Index Cond: (id @@@ '{..., "query": {"Parse": {"query_string": "description:book"}}, ...
```

While this query is still efficient, it would have been more efficient to write it using ParadeDB's query builder functions
as a single clause:

```sql
SELECT *
FROM paradedb.bm25_search
WHERE id @@@ paradedb.boolean(should => ARRAY [
        paradedb.boolean(must => ARRAY [
            paradedb.term('description', 'shoe'),
            paradedb.term('description', 'run')
            ]),
        paradedb.parse('description:book')
    ]);
```

This would have given us a query plan with a single IndexScan node:

```sql
                                                                                  QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Index Scan using bm25_search_bm25_index on bm25_search  (cost=10.00..14.05 rows=3 width=609)
   Index Cond: (id @@@ '{..., "query": {"Boolean": {"must": [], "should": [{"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, {"Parse": {"query_string": "description:book"}}], "must_not": []}}, ...
```

ParadeDB endeavors to reduce queries to a single IndexScan when it can, but sometimes it's not technically possible and
requires assistance from the user.

## Filtering with SQL

Recall from the overview that the ParadeDB index we made does not include the `category`.

As an example, to find all rows that are labeled as "brown" and are in the "footwear" category.

We can filter with SQL using:

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ 'metadata.color:brown'
   AND category = 'Footwear';
```

<Accordion title="Expected Response">
```csv
 id |     description      | rating | category | in_stock |                    metadata                     |     created_at      | last_updated_date | latest_available_time
----+----------------------+--------+----------+----------+-------------------------------------------------+---------------------+-------------------+-----------------------
 13 | Sturdy hiking boots  |      4 | Footwear | t        | {"color": "Brown", "location": "United States"} | 2023-05-05 13:45:22 | 2023-05-07        | 13:45:22
 23 | Comfortable slippers |      3 | Footwear | t        | {"color": "Brown", "location": "Canada"}        | 2023-04-16 09:20:37 | 2023-04-17        | 09:20:37
  5 | Generic shoes        |      4 | Footwear | t        | {"color": "Brown", "location": "Canada"}        | 2023-05-02 08:45:11 | 2023-05-03        | 08:45:11
(3 rows)
```
</Accordion>

## Query Expansion with SQL

Perhaps we want all rows that are described as "shoes" or "boots" plus everything in the "Home Decor" and "Furniture" categories:

```sql
SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ 'description:(shoes boots)'
   OR category IN ('Home Decor', 'Furniture');
```

<Accordion title="Expected Response">
```csv
 id |       description        | rating |  category  | in_stock |                       metadata                       |     created_at      | last_updated_date | latest_available_time
----+--------------------------+--------+------------+----------+------------------------------------------------------+---------------------+-------------------+-----------------------
  3 | Sleek running shoes      |      5 | Footwear   | t        | {"color": "Blue", "location": "China"}               | 2023-04-28 10:55:43 | 2023-04-29        | 10:55:43
  4 | White jogging shoes      |      3 | Footwear   | f        | {"color": "White", "location": "United States"}      | 2023-04-20 16:38:02 | 2023-04-22        | 16:38:02
  5 | Generic shoes            |      4 | Footwear   | t        | {"color": "Brown", "location": "Canada"}             | 2023-05-02 08:45:11 | 2023-05-03        | 08:45:11
  9 | Modern wall clock        |      4 | Home Decor | f        | {"color": "Silver", "location": "China"}             | 2023-04-24 12:37:52 | 2023-04-25        | 12:37:52
 13 | Sturdy hiking boots      |      4 | Footwear   | t        | {"color": "Brown", "location": "United States"}      | 2023-05-05 13:45:22 | 2023-05-07        | 13:45:22
 14 | Elegant glass table      |      3 | Furniture  | t        | {"color": "Clear", "location": "Canada"}             | 2023-04-26 17:22:58 | 2023-04-28        | 17:22:58
 19 | Artistic ceramic vase    |      4 | Home Decor | f        | {"color": "Multicolor", "location": "United States"} | 2023-04-19 15:17:29 | 2023-04-21        | 15:17:29
 24 | Classic leather sofa     |      5 | Furniture  | f        | {"color": "Brown", "location": "China"}              | 2023-05-06 14:45:27 | 2023-05-08        | 14:45:27
 29 | Designer wall paintings  |      5 | Home Decor | t        | {"color": "Multicolor", "location": "Canada"}        | 2023-04-30 14:18:37 | 2023-05-01        | 14:18:37
 34 | Rustic bookshelf         |      4 | Furniture  | t        | {"color": "Brown", "location": "United States"}      | 2023-04-24 08:20:47 | 2023-04-25        | 08:20:47
 39 | Handcrafted wooden frame |      5 | Home Decor | f        | {"color": "Brown", "location": "China"}              | 2023-04-19 08:55:06 | 2023-04-21        | 08:55:06
(11 rows)
```
</Accordion>

## Using SQL Aggregates

Maybe we want a breakdown of all categories of products from the United States with a rating greater than three, limited
to the top five by count.

```sql
  SELECT category,
         count(*)
    FROM paradedb.bm25_search
   WHERE id @@@ 'metadata.location:"United States"'
GROUP BY category, rating
  HAVING rating > 3
ORDER BY count(*) DESC, category
   LIMIT 5;
```

<Accordion title="Expected Response">
```csv
    category | count
-------------+-------
 Electronics | 2
     Apparel | 1
      Beauty | 1
    Footwear | 1
   Furniture | 1
(5 rows)
```
</Accordion>
