---
title: Understanding Query Plans
---

<Note>
  See the [overview](/api-reference/direct-sql/overview#getting-started) for
  creating the necessary example data
</Note>

When using the `@@@` operator, a query plan that uses an IndexScan (or even BitmapIndexScan) over the ParadeDB `USING bm25`
index is much preferred to situations where a Filter is instead applied to a SequentialScan. IndexScans enable ParadeDB
to optimize the "time to fist byte" for finding matching rows, consume significantly less memory, and will generally
execute faster.

Knowing that, there are times when Postgres simply has no other option than to use a SequentialScan, and in those cases,
that's fine -- it's the only option.

## Explaining an Index Scan

Looking at a complex query from the [text search and sql](/api-reference/direct-sql/mix-text-and-sql) section, lets
walk through what's going on:

```sql
EXPLAIN SELECT category,
         count(*)
    FROM paradedb.bm25_search
   WHERE id @@@ 'metadata.location:"United States"'
GROUP BY category, rating
  HAVING rating > 3
ORDER BY count(*) DESC, category
   LIMIT 5;

                                                            QUERY PLAN
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=14.49..14.50 rows=5 width=21)
   ->  Sort  (cost=14.49..14.51 rows=7 width=21)
         Sort Key: (count(*)) DESC, category
         ->  HashAggregate  (cost=14.32..14.39 rows=7 width=21)
               Group Key: category, rating
               ->  Index Scan using bm25_search_bm25_index on bm25_search  (cost=10.00..14.25 rows=10 width=13)
                     Index Cond: (id @@@ '{..., "query": {"Parse": {"query_string": "metadata.location:\"United States\""}}, ...
                     Filter: (rating > 3)
(8 rows)

--
-- returns these rows
--
  category   | count
-------------+-------
 Electronics |     2
 Apparel     |     1
 Beauty      |     1
 Footwear    |     1
 Furniture   |     1
(5 rows)
```

### The IndexScan node

Starting from the inner-most node, we see that Postgres has decided to do an `IndexScan` over the `bm25_search_bm25_index`
we initially created. This is the ParadeDB `USING bm25` index. This is decided because of the `id @@@ 'metadata.location:"United States"'`
clause.

### Filtering by rating

Within that node, we see that Postgres is applying a filter to the rows returned by the IndexScan's index condition, which
is `rating > 3`. This is from the `HAVING rating > 3` clause in the query.

### Grouping by category, rating

Moving upwards in the query plan, Postgres will then collect the values from the `category` and `rating` columns into an
internal hash table to perform the `GROUP BY category, rating` portion of the query.

### Final sorting and limit

Once collected, those results are then sorted by the count of rows for each unique category, and finally those results
are limited to the first five.

### Cost Estimates

One important piece of information to point out in the above plan is the `rows=10` estimate on the `Index Scan using` node.
This is an estimate of the number of rows that particular index scan will return, which again, is based on `id @@@ 'metadata.location:"United States"'`.
Interestingly, the _exactly_ number of rows that match just that query condition is 14.

ParadeDB's estimate of 10 is collected in real time from the underlying index using a strategy of querying a small portion
of the whole index and then extrapolating what the actual value might be. There's no special meaning to the value "10"
in this case -- that just happens to be our estimate.

It's perfectly fine that row estimates don't exactly match the real count. ParadeDB's goal is to quickly estimate a value
that's at least within the same order of magnitude. The closer the estimate is to the exact value, the better plans
Postgres is able to generate.

## Explaining a Bitmap Index Scan

Looking back at the `OR` query example, we have this:

```sql
EXPLAIN SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ paradedb.boolean(
            must => ARRAY [
                        paradedb.term('description', 'shoe'),
                        paradedb.term('description', 'run')
                    ]
              )
   OR id @@@ 'description:book';

                                                                                  QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on bm25_search  (cost=40.02..344.05 rows=3 width=609)
   Recheck Cond: ((id @@@ '{..., "query": {"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, ...
   ->  BitmapOr  (cost=20.02..20.02 rows=3 width=0)
         ->  Bitmap Index Scan on bm25_search_bm25_index  (cost=0.00..10.01 rows=1 width=0)
               Index Cond: (id @@@ '{..., "query": {"Boolean": {"must": [{"Term": {"field": "description", "value": "shoe"}}, {"Term": {"field": "description", "value": "run"}}], "should": [], "must_not": []}}, ...
         ->  Bitmap Index Scan on bm25_search_bm25_index  (cost=0.00..10.01 rows=2 width=0)
               Index Cond: (id @@@ '{..., "query": {"Parse": {"query_string": "description:book"}}, ...

--
-- returns these rows
--
 id |        description        | rating | category | in_stock |                       metadata                       |     created_at      | last_updated_date | latest_available_time
----+---------------------------+--------+----------+----------+------------------------------------------------------+---------------------+-------------------+-----------------------
  3 | Sleek running shoes       |      5 | Footwear | t        | {"color": "Blue", "location": "China"}               | 2023-04-28 10:55:43 | 2023-04-29        | 10:55:43
  7 | Hardcover book on history |      2 | Books    | t        | {"color": "Brown", "location": "United States"}      | 2023-04-18 14:59:27 | 2023-04-19        | 14:59:27
 37 | Historical fiction book   |      3 | Books    | t        | {"color": "Multicolor", "location": "United States"} | 2023-04-21 10:35:40 | 2023-04-22        | 10:35:40
(3 rows)
```

This is a much different query as it doesn't contain `GROUP BY`, `HAVING`, `ORDER BY` or `LIMIT` clauses, but it's
particularly complex in that Postgres must plan the separate `OR` conditions separately, and then solve the union
using bitmaps of the matching row identifiers.

### The BitmapIndexScan nodes

That's what we see happening here in that we have two Bitmap Index Scan nodes, each using a unique clause from the
original SQL.

While the `row=` estimates here are small (1, and 2 respectively), this is indicating that if either of those clauses
return, say, 10 million rows, then that's the number of rows that would need to be OR'd with the other clause.

### Combining with `BitmapOR`

Then their results are OR'd together by the containing `BitmapOr` node, producing the final output

### Cost Estimates

Again, the row estimate costs for this plan are very small, but with larger datasets and less selective queries, they
could be quite high. In this particular case it would be most efficient to rewrite this query in a manner that can
be answered by the index in a single Index Scan. Such as:

```sql
EXPLAIN SELECT *
  FROM paradedb.bm25_search
 WHERE id @@@ '(description:shoe AND description:run) OR description:book';
                                          QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------>
 Index Scan using bm25_search_bm25_index on bm25_search  (cost=10.00..14.05 rows=3 width=106)
   Index Cond: (id @@@ '{..., "query": {"Parse": {"query_string": "(description:shoe AND description:run) OR description:book"}}, ...
```

This is the same query and will return the same results, but in a more efficient way.

Bitmap scans are not necessarily always inefficient. In many queries, they're simply the only way Postgres can answer
the query. However, they're worth paying attention to when looking to improve query performance.
